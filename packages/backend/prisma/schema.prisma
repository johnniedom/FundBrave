generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== USER & AUTHENTICATION ====================

model User {
  id String @id @default(uuid())

  // Identity (Web3 Primary, Web2 Optional)
  walletAddress String  @unique
  username      String? @unique

  // Web2 Auth (Optional for hybrid users)
  email         String? @unique
  emailVerified Boolean @default(false)
  passwordHash  String?
  googleId      String?
  twitterId     String?

  // Managed Wallet (Encrypted for Web2 users)
  encryptedPrivateKey String?
  encryptionIv        String?

  // Profile
  displayName String?
  bio         String? @db.Text
  avatarUrl   String?
  bannerUrl   String?
  location    String?
  website     String?

  // Verification & Reputation
  worldIdVerified   Boolean            @default(false)
  worldIdNullifier  String?            @unique
  isVerifiedCreator Boolean            @default(false)
  verificationBadge VerificationBadge?
  reputationScore   Int                @default(0)

  // Social Stats (Denormalized for performance)
  followersCount   Int    @default(0)
  followingCount   Int    @default(0)
  postsCount       Int    @default(0)
  fundraisersCount Int    @default(0)
  totalDonated     BigInt @default(0) // Total amount donated (wei)
  totalStaked      BigInt @default(0) // Total amount staked (wei)

  // FBT Token Stats (Denormalized)
  fbtBalance       BigInt @default(0) // FBT balance (wei)
  fbtStakedBalance BigInt @default(0) // FBT staked in treasury (wei)
  fbtVestedTotal   BigInt @default(0) // Total FBT vested (wei)
  fbtVestedClaimed BigInt @default(0) // FBT claimed from vesting (wei)

  // Privacy
  isPrivate        Boolean @default(false)
  isActive         Boolean @default(true)
  isSuspended      Boolean @default(false)
  suspensionReason String?

  // Timestamps
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  lastSeenAt DateTime?

  // Relations
  posts            Post[]
  comments         Comment[]
  likes            Like[]
  bookmarks        Bookmark[]
  reposts          Repost[]
  followedBy       Follow[]                  @relation("following")
  following        Follow[]                  @relation("follower")
  blockedBy        Block[]                   @relation("blocking")
  blocking         Block[]                   @relation("blocked")
  fundraisers      Fundraiser[]
  donations        Donation[]
  stakes           Stake[]
  votes            Vote[]
  proposals        Proposal[]
  notifications    Notification[]            @relation("recipient")
  triggeredNotifs  Notification[]            @relation("actor")
  sentMessages     Message[]                 @relation("sender")
  receivedMessages Message[]                 @relation("receiver")
  conversations    ConversationParticipant[]
  sessions         Session[]
  activities       ActivityLog[]
  reports          Report[]                  @relation("reporter")
  reportedContent  Report[]                  @relation("reported")

  // Global Pool Relations
  globalVotes GlobalPoolVote[]
  fbtClaims   RewardClaim[]
  fbtLocks    GlobalPoolLock[]

  // New Contract Relations
  impactDAOStakes          ImpactDAOStake[]
  wealthBuildingDonations  WealthBuildingDonation[]
  donorStockPortfolios     DonorStockPortfolio[]
  fbtStakes                FBTStake[]
  fbtVestingSchedules      FBTVestingSchedule[]
  daoProposals             DAOProposal[]            @relation("proposer")
  daoVotes                 DAOVote[]

  notificationSetting NotificationSetting?
  deviceTokens        DeviceToken[]
  nonce               String?              @default(uuid())

  @@index([walletAddress])
  @@index([username])
  @@index([email])
  @@map("users")
}

enum VerificationBadge {
  NONE
  WORLD_ID
  VERIFIED_CREATOR
  OFFICIAL
  GOLD // For high-reputation users
}

model Session {
  id           String   @id @default(uuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token        String   @unique
  refreshToken String?  @unique
  expiresAt    DateTime
  ipAddress    String?
  userAgent    String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@map("sessions")
}

// ==================== SOCIAL GRAPH ====================

model Follow {
  id          String   @id @default(uuid())
  followerId  String
  followingId String
  follower    User     @relation("follower", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("following", fields: [followingId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

model Block {
  id        String   @id @default(uuid())
  blockerId String
  blockedId String
  blocker   User     @relation("blocking", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked   User     @relation("blocked", fields: [blockedId], references: [id], onDelete: Cascade)
  reason    String?
  createdAt DateTime @default(now())

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
  @@map("blocks")
}

// ==================== POSTS & CONTENT ====================

model Post {
  id      String   @id @default(uuid())
  content String?  @db.Text
  type    PostType @default(TEXT)

  // Author
  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Media
  mediaUrls String[]
  media     Media[]

  // Hashtags & Mentions
  tags     PostHashtag[]
  mentions String[]

  // Fundraiser link
  fundraiserId String?
  fundraiser   Fundraiser? @relation(fields: [fundraiserId], references: [id])

  // Thread/Reply
  parentId   String?
  parent     Post?   @relation("PostReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies    Post[]  @relation("PostReplies")
  replyCount Int     @default(0)

  // Engagement (Denormalized)
  likesCount      Int   @default(0)
  repostsCount    Int   @default(0)
  bookmarksCount  Int   @default(0)
  viewsCount      Int   @default(0)
  engagementScore Float @default(0) // Calculated for feed algorithm

  // Visibility
  visibility  PostVisibility @default(PUBLIC)
  isPinned    Boolean        @default(false)
  isEdited    Boolean        @default(false)
  editHistory Json?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  likes     Like[]
  reposts   Repost[]
  bookmarks Bookmark[]
  comments  Comment[]
  reports   Report[]

  @@index([authorId])
  @@index([fundraiserId])
  @@index([parentId])
  @@index([createdAt])
  @@index([engagementScore])
  @@map("posts")
}

model Hashtag {
  id  String @id @default(uuid())
  tag String @unique

  posts PostHashtag[]

  usageCount Int      @default(0)
  lastUsedAt DateTime @default(now())

  @@index([usageCount])
  @@map("hashtags")
}

// Join table for efficiency
model PostHashtag {
  postId    String
  post      Post    @relation(fields: [postId], references: [id], onDelete: Cascade)
  hashtagId String
  hashtag   Hashtag @relation(fields: [hashtagId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@id([postId, hashtagId])
  @@index([hashtagId])
  @@map("post_hashtags")
}

enum PostType {
  TEXT
  MEDIA
  POLL
  DONATION_EVENT
  FUNDRAISER_NEW
  FUNDRAISER_UPDATE
  MILESTONE_REACHED
}

enum PostVisibility {
  PUBLIC
  FOLLOWERS
  PRIVATE
}

model Media {
  id        String      @id @default(uuid())
  postId    String
  post      Post        @relation(fields: [postId], references: [id], onDelete: Cascade)
  url       String
  type      MediaType
  mimeType  String?
  size      Int? // bytes
  width     Int?
  height    Int?
  duration  Int? // seconds for video/audio
  thumbnail String?
  alt       String?
  status    MediaStatus @default(PROCESSING)
  createdAt DateTime    @default(now())

  @@index([postId])
  @@map("media")
}

enum MediaType {
  IMAGE
  VIDEO
  AUDIO
  GIF
}

enum MediaStatus {
  PROCESSING
  COMPLETED
  FAILED
}

model Comment {
  id       String @id @default(uuid())
  content  String @db.Text
  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  postId   String
  post     Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Nested comments
  parentId String?
  parent   Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Comment[] @relation("CommentReplies")

  likesCount Int           @default(0)
  likes      CommentLike[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId])
  @@index([authorId])
  @@index([parentId])
  @@map("comments")
}

model CommentLike {
  id        String   @id @default(uuid())
  userId    String
  commentId String
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, commentId])
  @@index([commentId])
  @@map("comment_likes")
}

model Like {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, postId])
  @@index([postId])
  @@index([userId])
  @@map("likes")
}

model Repost {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment   String?  @db.Text // Optional quote repost
  createdAt DateTime @default(now())

  @@unique([userId, postId])
  @@index([postId])
  @@index([userId])
  @@map("reposts")
}

model Bookmark {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, postId])
  @@index([userId])
  @@map("bookmarks")
}

// ==================== FUNDRAISING ====================

model Fundraiser {
  id        String @id @default(uuid())
  onChainId Int    @unique
  txHash    String @unique

  // Basic Info
  name        String
  description String   @db.Text
  images      String[]
  categories  String[]
  region      String?

  // Financials
  goalAmount   String @default("0") // Goal amount in USD (decimal string)
  raisedAmount BigInt @default(0)   // Raised amount (wei)
  currency     String @default("USDC")

  // Endowment Tracking (for WealthBuildingDonation)
  endowmentEnabled   Boolean @default(false)
  endowmentPrincipal BigInt  @default(0) // Total endowment principal (wei)
  endowmentYield     BigInt  @default(0) // Total yield generated (wei)

  // Addresses
  beneficiary     String
  stakingPoolAddr String?

  // Creator
  creatorId String
  creator   User   @relation(fields: [creatorId], references: [id])

  // Timeline
  deadline  DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Status
  isActive    Boolean @default(true)
  isFeatured  Boolean @default(false)
  goalReached Boolean @default(false)

  // Stats (Denormalized)
  donorsCount  Int @default(0)
  stakersCount Int @default(0)
  updatesCount Int @default(0)

  // Relations
  donations              Donation[]
  stakes                 Stake[]
  posts                  Post[]
  updates                FundraiserUpdate[]
  milestones             Milestone[]
  proposals              Proposal[]
  votes                  Vote[]
  globalVotes            GlobalPoolVote[]
  wealthBuildingDonations WealthBuildingDonation[]

  @@index([creatorId])
  @@index([onChainId])
  @@index([isActive])
  @@index([goalReached])
  @@map("fundraisers")
}

model FundraiserUpdate {
  id           String     @id @default(uuid())
  fundraiserId String
  fundraiser   Fundraiser @relation(fields: [fundraiserId], references: [id], onDelete: Cascade)
  title        String
  content      String     @db.Text
  mediaUrls    String[]
  createdAt    DateTime   @default(now())

  @@index([fundraiserId])
  @@map("fundraiser_updates")
}

model Milestone {
  id           String     @id @default(uuid())
  fundraiserId String
  fundraiser   Fundraiser @relation(fields: [fundraiserId], references: [id], onDelete: Cascade)
  title        String
  description  String?
  targetAmount BigInt     // Target amount (wei)
  isReached    Boolean    @default(false)
  reachedAt    DateTime?
  createdAt    DateTime   @default(now())

  @@index([fundraiserId])
  @@map("milestones")
}

model Donation {
  id     String @id @default(uuid())
  txHash String @unique

  // Amounts
  amount    BigInt // Original blockchain amount (wei)
  amountUSD String // Converted to USD (decimal string)
  token     String // Token symbol

  // Blockchain
  chainId     Int
  sourceChain String
  blockNumber Int?

  // Donor
  donorId      String?
  donor        User?   @relation(fields: [donorId], references: [id])
  donorAddress String

  // Fundraiser
  fundraiserId String
  fundraiser   Fundraiser @relation(fields: [fundraiserId], references: [id])

  // Metadata
  isAnonymous Boolean @default(false)
  message     String?

  // Timestamps
  createdAt DateTime @default(now())
  indexedAt DateTime @default(now())

  @@index([fundraiserId])
  @@index([donorId])
  @@index([donorAddress])
  @@index([txHash])
  @@map("donations")
}

model Stake {
  id          String @id @default(uuid())
  txHash      String @unique
  poolAddress String
  amount      BigInt // Staked amount (wei)
  shares      BigInt // Receipt tokens (wei)

  fundraiserId String?
  fundraiser   Fundraiser? @relation(fields: [fundraiserId], references: [id])

  // Staker
  stakerId      String
  staker        User   @relation(fields: [stakerId], references: [id])
  stakerAddress String

  // Yield Split Configuration (for enhanced StakingPool)
  causeShare    Int? // Basis points to cause
  stakerShare   Int? // Basis points to staker
  platformShare Int? // Basis points to platform

  // Blockchain
  chainId     Int
  blockNumber Int?

  // Status
  isActive Boolean @default(true)
  isGlobal Boolean @default(false)

  // Timestamps
  stakedAt   DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  unstakedAt DateTime?

  @@index([stakerId])
  @@index([fundraiserId])
  @@index([poolAddress])
  @@map("stakes")
}

model Proposal {
  id           String     @id @default(uuid())
  onChainId    Int        @unique
  fundraiserId String
  fundraiser   Fundraiser @relation(fields: [fundraiserId], references: [id])

  // Content
  title       String
  description String @db.Text

  // Creator
  creatorId String
  creator   User   @relation(fields: [creatorId], references: [id])

  // Voting
  requiredVotes BigInt // Required votes (wei)
  upvotes       BigInt @default(0)
  downvotes     BigInt @default(0)

  // Status
  executed   Boolean   @default(false)
  executedAt DateTime?

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  votes Vote[]

  @@index([fundraiserId])
  @@index([onChainId])
  @@map("proposals")
}

model Vote {
  id           String     @id @default(uuid())
  proposalId   String
  proposal     Proposal   @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  fundraiserId String
  fundraiser   Fundraiser @relation(fields: [fundraiserId], references: [id])
  voterId      String
  voter        User       @relation(fields: [voterId], references: [id])
  isUpvote     Boolean
  votingPower  BigInt     // Amount of USDC donated (wei)
  createdAt    DateTime   @default(now())

  @@unique([proposalId, voterId])
  @@index([proposalId])
  @@map("votes")
}

// ==================== IMPACT DAO POOL ====================

model ImpactDAOStake {
  id     String @id @default(uuid())
  txHash String @unique

  // Staker
  stakerId      String
  staker        User   @relation(fields: [stakerId], references: [id])
  stakerAddress String

  // Amounts
  principal BigInt // USDC principal staked (wei)

  // Yield Split Configuration
  daoShare      Int @default(7900) // Basis points (79% default)
  stakerShare   Int @default(1900) // Basis points (19% default)
  platformShare Int @default(200)  // Basis points (2% default, minimum)

  // Accumulated Yields
  pendingUSDCYield BigInt @default(0)
  pendingFBTReward BigInt @default(0)
  claimedUSDCYield BigInt @default(0)
  claimedFBTReward BigInt @default(0)

  // Blockchain
  chainId     Int
  blockNumber Int?

  // Status
  isActive Boolean @default(true)

  // Timestamps
  stakedAt   DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  unstakedAt DateTime?

  // Relations
  yieldHarvests ImpactDAOYieldHarvest[]

  @@index([stakerId])
  @@index([stakerAddress])
  @@index([isActive])
  @@map("impact_dao_stakes")
}

model ImpactDAOYieldHarvest {
  id String @id @default(uuid())

  // Stake reference
  stakeId String
  stake   ImpactDAOStake @relation(fields: [stakeId], references: [id], onDelete: Cascade)

  // Yield amounts
  totalYield     BigInt // Total yield before split (wei)
  daoAmount      BigInt // Amount to YieldDistributor (wei)
  stakerAmount   BigInt // Amount to staker (wei)
  platformAmount BigInt // Amount to platform (wei)

  // Transaction
  txHash      String   @unique
  blockNumber Int?
  chainId     Int

  // Timestamp
  harvestedAt DateTime @default(now())

  @@index([stakeId])
  @@map("impact_dao_yield_harvests")
}

model ImpactDAOPoolStats {
  id String @id @default(uuid())

  // Pool Statistics
  totalStakedPrincipal BigInt @default(0)
  totalYieldHarvested  BigInt @default(0)
  totalFBTDistributed  BigInt @default(0)
  stakersCount         Int    @default(0)

  // Reward Configuration
  rewardRate        BigInt @default(0) // FBT per second (wei)
  periodFinish      DateTime?
  rewardsDuration   Int    @default(604800) // 7 days in seconds

  // Last Update
  lastHarvestAt DateTime?
  updatedAt     DateTime  @updatedAt

  @@map("impact_dao_pool_stats")
}

// ==================== WEALTH BUILDING DONATION ====================

model WealthBuildingDonation {
  id     String @id @default(uuid())
  txHash String @unique

  // Donor
  donorId      String
  donor        User   @relation(fields: [donorId], references: [id])
  donorAddress String

  // Fundraiser
  fundraiserId   String
  fundraiser     Fundraiser @relation(fields: [fundraiserId], references: [id])
  beneficiaryAddr String

  // Donation Amounts
  totalAmount     BigInt // Total donation (wei)
  directAmount    BigInt // 78% to beneficiary (wei)
  endowmentAmount BigInt // 20% to Aave (wei)
  platformFee     BigInt // 2% platform fee (wei)

  // Endowment Tracking
  endowmentPrincipal BigInt @default(0)
  lifetimeYield      BigInt @default(0)
  causeYieldPaid     BigInt @default(0)
  donorStockValue    BigInt @default(0)

  // Blockchain
  chainId     Int
  blockNumber Int?

  // Timestamps
  createdAt        DateTime  @default(now())
  lastHarvestAt    DateTime?
  updatedAt        DateTime  @updatedAt

  // Relations
  yieldHarvests WealthBuildingYieldHarvest[]
  stockPortfolio DonorStockPortfolio[]

  @@index([donorId])
  @@index([fundraiserId])
  @@index([donorAddress])
  @@map("wealth_building_donations")
}

model WealthBuildingYieldHarvest {
  id String @id @default(uuid())

  // Donation reference
  donationId String
  donation   WealthBuildingDonation @relation(fields: [donationId], references: [id], onDelete: Cascade)

  // Yield amounts
  yieldAmount BigInt // Total yield (wei)
  causeShare  BigInt // 30% to fundraiser (wei)
  donorShare  BigInt // 70% to donor as stocks (wei)

  // Transaction
  txHash      String   @unique
  blockNumber Int?
  chainId     Int

  // Timestamp
  harvestedAt DateTime @default(now())

  @@index([donationId])
  @@map("wealth_building_yield_harvests")
}

model DonorStockPortfolio {
  id String @id @default(uuid())

  // Owner
  donorId      String
  donor        User   @relation(fields: [donorId], references: [id])
  donorAddress String

  // Stock Token
  stockToken   String // Address of tokenized stock (e.g., bCSPX)
  stockSymbol  String // Symbol for display
  stockBalance BigInt // Amount of stock tokens (wei)

  // Value Tracking
  totalUSDCInvested BigInt @default(0) // Total USDC swapped to stocks (wei)
  currentValueUSD   BigInt @default(0) // Estimated current value (wei)

  // Source Donation (optional)
  donationId String?
  donation   WealthBuildingDonation? @relation(fields: [donationId], references: [id])

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([donorId, stockToken])
  @@index([donorId])
  @@index([stockToken])
  @@map("donor_stock_portfolios")
}

model StockPurchase {
  id String @id @default(uuid())

  // Donor
  donorAddress String

  // Transaction details
  stockToken    String // Stock token address
  stockSymbol   String
  usdcAmount    BigInt // USDC used for purchase (wei)
  stockAmount   BigInt // Stock tokens received (wei)

  // Blockchain
  txHash      String   @unique
  blockNumber Int?
  chainId     Int

  // Timestamp
  purchasedAt DateTime @default(now())

  @@index([donorAddress])
  @@index([stockToken])
  @@map("stock_purchases")
}

model SupportedStock {
  id String @id @default(uuid())

  // Token Info
  tokenAddress String @unique
  symbol       String
  name         String
  decimals     Int    @default(18)

  // Backed Finance specific
  isBackedToken Boolean @default(true)
  underlyingAsset String? // e.g., "S&P 500" for bCSPX

  // Status
  isActive  Boolean @default(true)
  isDefault Boolean @default(false)

  // Price tracking
  lastPrice    String?   // Last known price in USD
  lastPriceAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("supported_stocks")
}

// ==================== PLATFORM TREASURY ====================

model PlatformFee {
  id String @id @default(uuid())

  // Source
  sourceContract String // Contract address that sent the fee
  sourceType     FeeSourceType

  // Amount
  amount BigInt // USDC amount (wei)

  // Transaction
  txHash      String   @unique
  blockNumber Int?
  chainId     Int

  // Staking Status
  isStaked   Boolean   @default(false)
  stakedAt   DateTime?
  stakedTxHash String?

  // Timestamp
  receivedAt DateTime @default(now())

  @@index([sourceContract])
  @@index([sourceType])
  @@index([isStaked])
  @@map("platform_fees")
}

enum FeeSourceType {
  STAKING_POOL
  IMPACT_DAO_POOL
  WEALTH_BUILDING
  FUNDRAISER
  OTHER
}

model FBTStake {
  id String @id @default(uuid())

  // Staker
  stakerId      String
  staker        User   @relation(fields: [stakerId], references: [id])
  stakerAddress String

  // Stake Amount
  amount BigInt // FBT staked (wei)

  // Yield Tracking
  pendingYield BigInt @default(0) // USDC yield from treasury (wei)
  claimedYield BigInt @default(0)

  // Transaction
  txHash      String @unique
  blockNumber Int?
  chainId     Int

  // Status
  isActive Boolean @default(true)

  // Timestamps
  stakedAt   DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  unstakedAt DateTime?

  @@index([stakerId])
  @@index([stakerAddress])
  @@index([isActive])
  @@map("fbt_stakes")
}

model TreasuryStats {
  id String @id @default(uuid())

  // Fee Statistics
  totalFeesCollected   BigInt @default(0)
  totalFeesStaked      BigInt @default(0)
  pendingFeesToStake   BigInt @default(0)

  // FBT Staking
  totalFBTStaked       BigInt @default(0)

  // Yield Statistics
  totalYieldDistributed BigInt @default(0)
  operationalFunds      BigInt @default(0)

  // Endowment (via WealthBuildingDonation)
  endowmentPrincipal     BigInt @default(0)
  endowmentLifetimeYield BigInt @default(0)

  // Configuration
  minStakeThreshold    BigInt @default(1000000000) // 1000 USDC (wei)

  // Timestamps
  lastFeeStakedAt      DateTime?
  lastYieldHarvestedAt DateTime?
  updatedAt            DateTime @updatedAt

  @@map("treasury_stats")
}

// ==================== FBT VESTING ====================

model FBTVestingSchedule {
  id String @id @default(uuid())

  // Recipient
  recipientId      String
  recipient        User   @relation(fields: [recipientId], references: [id])
  recipientAddress String

  // Schedule Details
  totalAmount      BigInt // Total tokens to vest (wei)
  releasedAmount   BigInt @default(0) // Already claimed (wei)
  startTime        DateTime
  duration         Int    // Duration in seconds
  vestingType      VestingType

  // Calculated fields (denormalized for performance)
  claimableAmount  BigInt  @default(0)
  isFullyVested    Boolean @default(false)
  isFullyClaimed   Boolean @default(false)

  // Transaction (if created on-chain)
  txHash      String? @unique
  blockNumber Int?
  chainId     Int?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Claims
  claims FBTVestingClaim[]

  @@index([recipientId])
  @@index([recipientAddress])
  @@index([vestingType])
  @@map("fbt_vesting_schedules")
}

enum VestingType {
  DONATION_REWARD    // 30 days
  ENGAGEMENT_REWARD  // 7 days
  TEAM_ALLOCATION    // Custom
  INVESTOR           // Custom
  ECOSYSTEM          // Custom
}

model FBTVestingClaim {
  id String @id @default(uuid())

  // Schedule reference
  scheduleId String
  schedule   FBTVestingSchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)

  // Claim details
  amount BigInt // Claimed amount (wei)

  // Transaction
  txHash      String   @unique
  blockNumber Int?
  chainId     Int

  // Timestamp
  claimedAt DateTime @default(now())

  @@index([scheduleId])
  @@map("fbt_vesting_claims")
}

model FBTBurn {
  id String @id @default(uuid())

  // Burner
  burnerAddress String

  // Burn details
  amount BigInt // Burned amount (wei)
  reason String? // e.g., "premium_feature", "governance_burn"

  // Transaction
  txHash      String   @unique
  blockNumber Int?
  chainId     Int

  // Timestamp
  burnedAt DateTime @default(now())

  @@index([burnerAddress])
  @@map("fbt_burns")
}

// ==================== DAO VOTING (OFF-CHAIN) ====================

model DAOProposal {
  id String @id @default(uuid())

  // Proposal Content
  title       String
  description String   @db.Text
  category    ProposalCategory

  // Proposer
  proposerId String
  proposer   User   @relation("proposer", fields: [proposerId], references: [id])

  // Voting Configuration
  votingStartTime DateTime
  votingEndTime   DateTime
  quorumRequired  BigInt // Minimum FBT voting power needed (wei)

  // Results
  totalVotesFor     BigInt @default(0)
  totalVotesAgainst BigInt @default(0)
  totalVotesAbstain BigInt @default(0)
  votersCount       Int    @default(0)

  // Status
  status         ProposalStatus @default(ACTIVE)
  executedAt     DateTime?
  executionTxHash String?

  // For yield distribution proposals
  targetFundraisers Json? // Array of fundraiser IDs and allocation percentages

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  votes DAOVote[]

  @@index([proposerId])
  @@index([status])
  @@index([votingEndTime])
  @@map("dao_proposals")
}

enum ProposalCategory {
  YIELD_DISTRIBUTION   // Allocate DAO yield to fundraisers
  PARAMETER_CHANGE     // Change platform parameters
  FEATURE_REQUEST      // Request new features
  EMERGENCY            // Emergency actions
  OTHER
}

enum ProposalStatus {
  DRAFT
  ACTIVE
  PASSED
  REJECTED
  EXECUTED
  CANCELLED
}

model DAOVote {
  id String @id @default(uuid())

  // Proposal
  proposalId String
  proposal   DAOProposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)

  // Voter
  voterId String
  voter   User   @relation(fields: [voterId], references: [id])

  // Vote
  choice      VoteChoice
  votingPower BigInt // FBT voting power at time of vote (wei)

  // Signature (for off-chain voting verification)
  signature String?
  message   String?

  // Timestamps
  createdAt DateTime @default(now())

  @@unique([proposalId, voterId])
  @@index([proposalId])
  @@index([voterId])
  @@map("dao_votes")
}

enum VoteChoice {
  FOR
  AGAINST
  ABSTAIN
}

// ==================== NOTIFICATIONS ====================

model Notification {
  id String @id @default(uuid())

  // Recipient
  recipientId String
  recipient   User   @relation("recipient", fields: [recipientId], references: [id], onDelete: Cascade)

  // Actor (who triggered the notification)
  actorId String?
  actor   User?   @relation("actor", fields: [actorId], references: [id], onDelete: SetNull)

  // Type & Content
  type    NotificationType
  title   String?
  message String?

  // Related entities
  entityId   String? // Post, Fundraiser, etc.
  entityType String? // 'post', 'fundraiser', 'donation'

  // Metadata
  metadata Json?

  // Status
  read   Boolean   @default(false)
  readAt DateTime?

  // Timestamps
  createdAt DateTime @default(now())

  @@index([recipientId])
  @@index([actorId])
  @@index([read])
  @@index([createdAt])
  @@map("notifications")
}

enum NotificationType {
  LIKE
  COMMENT
  REPOST
  FOLLOW
  MENTION
  DONATION_RECEIVED
  STAKE_RECEIVED
  GOAL_REACHED
  MILESTONE_REACHED
  PROPOSAL_CREATED
  PROPOSAL_EXECUTED
  MESSAGE
  SYSTEM
  // New notification types
  YIELD_HARVESTED
  STOCK_PURCHASED
  FBT_VESTED
  FBT_REWARD
  DAO_VOTE_STARTED
  DAO_VOTE_ENDED
}

// ==================== MESSAGING ====================

model Conversation {
  id            String                    @id @default(uuid())
  participants  ConversationParticipant[]
  messages      Message[]
  lastMessageAt DateTime?
  createdAt     DateTime                  @default(now())
  updatedAt     DateTime                  @updatedAt

  @@map("conversations")
}

model ConversationParticipant {
  id             String       @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  joinedAt       DateTime     @default(now())
  lastReadAt     DateTime?

  @@unique([conversationId, userId])
  @@index([userId])
  @@map("conversation_participants")
}

model Message {
  id             String       @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId       String
  sender         User         @relation("sender", fields: [senderId], references: [id], onDelete: Cascade)
  receiverId     String
  receiver       User         @relation("receiver", fields: [receiverId], references: [id], onDelete: Cascade)
  content        String       @db.Text
  mediaUrl       String?
  read           Boolean      @default(false)
  readAt         DateTime?
  createdAt      DateTime     @default(now())

  @@index([conversationId])
  @@index([senderId])
  @@index([receiverId])
  @@map("messages")
}

// ==================== MODERATION & SAFETY ====================

model Report {
  id          String       @id @default(uuid())
  reporterId  String
  reporter    User         @relation("reporter", fields: [reporterId], references: [id])
  reportedId  String
  reported    User         @relation("reported", fields: [reportedId], references: [id])
  postId      String?
  post        Post?        @relation(fields: [postId], references: [id])
  entityId    String? // Post, Comment, etc.
  entityType  String?
  reason      ReportReason
  description String?      @db.Text
  status      ReportStatus @default(PENDING)
  resolvedAt  DateTime?
  resolvedBy  String?
  createdAt   DateTime     @default(now())

  @@index([reporterId])
  @@index([reportedId])
  @@index([postId])
  @@index([status])
  @@map("reports")
}

enum ReportReason {
  SPAM
  HARASSMENT
  HATE_SPEECH
  VIOLENCE
  SCAM
  FAKE_FUNDRAISER
  INAPPROPRIATE_CONTENT
  OTHER
}

enum ReportStatus {
  PENDING
  REVIEWED
  RESOLVED
  DISMISSED
}

// ==================== ANALYTICS & TRACKING ====================

model ActivityLog {
  id         String       @id @default(uuid())
  userId     String?
  user       User?        @relation(fields: [userId], references: [id], onDelete: SetNull)
  action     ActivityType
  entityId   String?
  entityType String?
  metadata   Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime     @default(now())

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("activity_logs")
}

enum ActivityType {
  POST_CREATE
  POST_VIEW
  POST_LIKE
  POST_UNLIKE
  POST_REPOST
  POST_BOOKMARK
  COMMENT_CREATE
  FOLLOW
  UNFOLLOW
  DONATION_CREATE
  STAKE_CREATE
  PROPOSAL_CREATE
  VOTE_CAST
  PROFILE_VIEW
  FUNDRAISER_VIEW
  SEARCH
  // New activity types
  IMPACT_DAO_STAKE
  IMPACT_DAO_UNSTAKE
  WEALTH_BUILDING_DONATE
  FBT_STAKE
  FBT_UNSTAKE
  FBT_VEST_CLAIM
  DAO_VOTE
  YIELD_HARVEST
  STOCK_CLAIM
}

model Trending {
  id           String   @id @default(uuid())
  type         String // 'hashtag', 'fundraiser', 'user'
  value        String // The actual hashtag, fundraiser ID, or user ID
  score        Float // Trending score
  postsCount   Int      @default(0)
  period       String // '1h', '24h', '7d'
  calculatedAt DateTime @default(now())

  @@unique([type, value, period])
  @@index([type, period, score])
  @@map("trending")
}

// ==================== BLOCKCHAIN SYNC ====================

model BlockchainSync {
  id              String   @id @default(uuid())
  chainId         Int
  chainName       String
  contractAddress String
  contractName    String?  // e.g., "ImpactDAOPool", "WealthBuildingDonation"
  lastBlock       Int      @default(0)
  lastSyncAt      DateTime @default(now())
  status          SyncStatus @default(SYNCING)
  error           String?

  @@unique([chainId, contractAddress])
  @@index([contractName])
  @@map("blockchain_sync")
}

enum SyncStatus {
  SYNCING
  SYNCED
  ERROR
  PAUSED
}

model BlockchainEvent {
  id              String   @id @default(uuid())

  // Event Info
  eventName       String
  contractAddress String
  contractName    String?

  // Transaction
  txHash          String
  blockNumber     Int
  logIndex        Int
  chainId         Int

  // Event Data
  args            Json     // Event arguments

  // Processing
  processed       Boolean  @default(false)
  processedAt     DateTime?
  error           String?

  // Timestamps
  blockTimestamp  DateTime
  indexedAt       DateTime @default(now())

  @@unique([txHash, logIndex, chainId])
  @@index([eventName])
  @@index([contractAddress])
  @@index([processed])
  @@index([blockNumber])
  @@map("blockchain_events")
}

model NotificationSetting {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Channels
  emailEnabled Boolean @default(true)
  pushEnabled  Boolean @default(true)

  // Granular Controls
  notifyOnLike     Boolean @default(true)
  notifyOnComment  Boolean @default(true)
  notifyOnFollow   Boolean @default(true)
  notifyOnMention  Boolean @default(true)
  notifyOnDonation Boolean @default(true) // "Someone donated to your fundraiser"
  notifyOnStake    Boolean @default(true)

  // New notification controls
  notifyOnYieldHarvest Boolean @default(true)
  notifyOnStockPurchase Boolean @default(true)
  notifyOnFBTVesting   Boolean @default(true)
  notifyOnDAOProposal  Boolean @default(true)

  updatedAt DateTime @updatedAt

  @@map("notification_settings")
}

model DeviceToken {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  token    String @unique // The Firebase/APNS token
  platform String // 'IOS', 'ANDROID', 'WEB'

  lastUsedAt DateTime @default(now())
  createdAt  DateTime @default(now())

  @@index([userId])
  @@map("device_tokens")
}

model SupportedChain {
  id          Int    @id
  name        String
  rpcUrl      String
  explorerUrl String

  isActive Boolean          @default(true)
  tokens   SupportedToken[]

  @@map("supported_chains")
}

model SupportedToken {
  id       String @id @default(uuid())
  symbol   String
  name     String
  decimals Int    @default(18)

  chainId Int
  chain   SupportedChain @relation(fields: [chainId], references: [id])

  address String
  logoUrl String?

  isActive Boolean @default(true)

  @@unique([chainId, address])
  @@unique([chainId, symbol])
  @@map("supported_tokens")
}

// ==================== GLOBAL POOL & VOTING ====================

model GlobalPoolEpoch {
  id          String   @id @default(uuid())
  epochNumber Int      @unique
  startDate   DateTime
  endDate     DateTime
  totalYield  BigInt   @default(0) // Total yield for epoch (wei)

  isCalculated  Boolean @default(false)
  isDistributed Boolean @default(false)

  distributionTx String?

  votes GlobalPoolVote[]

  @@map("global_pool_epochs")
}

model GlobalPoolVote {
  id String @id @default(uuid())

  epochId String
  epoch   GlobalPoolEpoch @relation(fields: [epochId], references: [id])

  voterId String
  voter   User   @relation(fields: [voterId], references: [id])

  fundraiserId String
  fundraiser   Fundraiser @relation(fields: [fundraiserId], references: [id])

  weight BigInt // Voting weight (wei)

  createdAt DateTime @default(now())

  @@unique([epochId, voterId, fundraiserId])
  @@index([epochId])
  @@map("global_pool_votes")
}

// ==================== HYBRID FBT TOKENOMICS ====================

model GlobalPoolLock {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id])

  amount      BigInt   // Locked amount (wei)
  unlockDate  DateTime
  multiplier  Float
  votingPower BigInt   // Calculated voting power (wei)

  createdAt DateTime @default(now())

  @@index([userId])
  @@map("global_pool_locks")
}

model RewardClaim {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id])

  amount BigInt // Claimed reward amount (wei)
  txHash String @unique

  claimedAt DateTime @default(now())

  @@index([userId])
  @@map("reward_claims")
}

// ==================== CONTRACT ADDRESSES REGISTRY ====================

model ContractRegistry {
  id String @id @default(uuid())

  chainId         Int
  contractName    String  // e.g., "ImpactDAOPool", "WealthBuildingDonation"
  contractAddress String
  deploymentTx    String?
  deploymentBlock Int?

  // ABI version for upgrade tracking
  version         String  @default("1.0.0")

  isActive        Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([chainId, contractName])
  @@unique([chainId, contractAddress])
  @@index([contractName])
  @@map("contract_registry")
}
